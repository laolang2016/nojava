---
title: C++ 基本语法
date: 2024-12-22 22:33:40
categories:
- C++
tags:
- C++
---

# 参考资料

[C++ 那些事](https://light-city.github.io/stories_things/)

[透彻理解C++11 移动语义：右值、右值引用、std::move、std::forward](https://www.cnblogs.com/KillerAery/p/12802771.html)

[C++高级特性](https://blog.csdn.net/weixin_43808717/category_12637774.html)

# const

## 含义

`const` 修饰的变量, 只是在语法上不能修改变量的值, 也就是只读变量, 除此之外和其他变量没有区别

## C 和 C++ 中常量与常变量

### 关于常量与常变量

1. C 语言中只有常变量
2. C++ 中两者都有

### C 语言中的常变量

```c
#include <stdio.h>
int main() {
	const int a = 1;
#if !defined(_MSC_VER)
	int arr[a] = {}; // vc 中会报错
#endif
	int* p = (int*)&a;
	*p = 2;
	printf("%d %d %d\n", a, *p, *(&a));
	return 0;
}
```

在 gcc 下输出如下
```
2 2 2
```

这里 `gcc` 下使用常变量指定数组大小没有报错, 是因为在 `C99` 之前, 数组的大小只能由常量指定, `C99` 之后可以使用变量指定, 这叫做变长数组. 所谓变长数组并不是数组长度可以改变, 而是可以使用变量指定数组大小, 且有如下几个限制

1. 变长数组的根本特征就是数组长度只有运行时才能确定，所以**变长数组不能初始化**。
2. 变长数组的优点是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。
3. **变长数组只能是局部变量数组**。
4. 变长数组不等于动态数组，其**本质还是静态数组，也就是数组的长度在变量的整个生命周期中是不可变的**。
5. **变长数组对于多维数组同样适用**（如：`arr[a][b]`)。




### C++ 中的常量
```c++
#include <iostream>

int main() {
    const int b = 1;
#if !defined(_MSC_VER)
    int arr[b] = {};  // vc 中会报错
#endif

    int* p = (int*)&b;
    *p     = 2;
    std::cout << b << " " << *p << " " << *(&b) << std::endl;

    return 0;
}
```

`C++` 中 `const` 修饰的量,且使用立即数初始化的,即为常量. 

上述代码在 `gcc` / `clang++` 中输出如下
```
1 2 2
```

在 vs2022 中输出如下
```
1 2 1
```

注意:

1. 此时 `b` 指向的内存已经改变
2. `*(&b)` 的值在不同的编译器中结果可能不一样(针对 `b` 是常量来说), 这属于未定义行为
3. 在 `C++` 中, 对于常量来说, 所有出现 `const` 常量名的地方, 都被当做常量的初始化替换了
4. 在 `C` 中, `const` 就是当做一个普通变量,只不过生命式建议初始化, 因为后续没有初始化的机会了

### C++ 中的常变量
```c++
#include <iostream>

int main() {
	int       a = 1;
	const int b = a;
#if !defined(_MSC_VER)
	int arr[b] = {};  // vc 中会报错
#endif

	int* p = (int*)&b;
	*p = 2;
	std::cout << b << " " << *p << " " << *(&b) << std::endl;

	return 0;
}
```

此时 `gcc` / `clang++` / `vs2022` 输出一致
```
2 2 2
```

使用 `const` 修饰的量使用变量初始化时,叫做常变量

### 总结
在 `C` 语言中，`const` 就是被当作一个普通的变量处理，编译生产指令；
在 `C++` 中，所有出现 `const` 名字的地方，都被常量的初始值进行类似文本替换一样的替换掉了,这是因为编译方式不同, 此时常量不能作为左值
在 `C++` 中, 使用另一个变量初始化, 则为常变量, 与 `C` 语言表现一致

### 参考
[详解C99中的变长数组（轻松学会）](https://blog.csdn.net/2302_80706750/article/details/136636438)
[C++/C中const的区别（常量和常变量）](https://blog.csdn.net/KingOfMyHeart/article/details/114334878)
[C和C++中经const修饰的常量、常变量和普通变量的区别](https://cloud.tencent.com/developer/article/1946570)

## const 与指针

### 有几种
```c++
// 指向const对象的指针或者说指向常量的指针。
const char * a; 
// 同上
char const * a; 
// 指向类型对象的const指针。或者说常指针、const指针。
char * const a; 
// 指向const对象的const指针。
const char * const a; 
```

> 如果 `const` 位于 `*` 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
> 如果 `const` 位于 `*` 的右侧，const就是修饰指针本身，即指针本身是常量。

<table>
    <tr>
        <td width="170">形式</td>
        <td width="150">名称</td>
        <td>特点</td>
    </tr>
    <tr>
        <td>
            const int *p=&a; <br />
            int const * p = &a;</td>
        <td>常量指针</td>
        <td>
            指针的指向可以修改，但是指针指向的值不可以修改。 <br />
            常量指针，首先要是常量。就是指向的值要是一个常量，但是指向的内存地址不做限制
        </td>
    </tr>
    <tr>
        <td>int * const p =&a;</td>
        <td>指针常量</td>
        <td>
            指针的指向不可以修改，指针指向的内存的值可以修改 , 也就是必须初始化<br />
            因为const的功能就是限定不可以修改，所以我们看到指针常量是先有了int *指针，再有的const修饰p 所以p的值(指向的内存地址) 是不可以修改的 <br />
            也就是const限制的是指针p的值，但是没有限定p指向的内存地址里的数据，所以内存的数据可以修改</td>
    </tr>
    <tr>
        <td>const int const *p=&a;</td>
        <td>指向常量的常指针</td>
        <td>指针的指向不可以修改，指针指向的值也不可以修改</td>
    </tr>
</table>

### 举例

```c++
#include <iostream>

void fun1();
void fun2();
void fun3();

int main() {
    fun1();
    fun2();
    fun3();
    return 0;
}

void fun1() {
    std::cout << "常量指针" << std::endl;
    int        a = 10;
    int        b = 20;
    const int *p = &a;  // 常量指针
    std::cout << a << " " << b << " " << *p << std::endl;

    // *p = 20;  // 错误，指向的内存地址中的数据不可以修改
    p = &b;  // 正确，指向的内存地址可以修改
    std::cout << a << " " << b << " " << *p << std::endl;

    std::cout << "常量指针" << std::endl << std::endl;
}
void fun2() {
    std::cout << "指针常量" << std::endl;
    int        a = 10;
    int        b = 20;
    int *const p = &a;  // 常量指针
    std::cout << a << " " << b << " " << *p << std::endl;

    // p  = &b;  // 错误，指向的内存地址不可以修改
    *p = 20;  // 正确，指向的内存地址中的数据可以修改

    std::cout << a << " " << b << " " << *p << std::endl;

    std::cout << "指针常量" << std::endl << std::endl;
}
void fun3() {
    std::cout << "指向常量的常指针" << std::endl;
    int              a = 10;
    int              b = 20;
    const int *const p = &a;  // 常量指针
    std::cout << a << " " << b << " " << *p << std::endl;

    // p  = &b;  // 错误，指向的内存地址不可以修改
    // *p = 20;  // 错误，指向的内存地址中的数据不可以修改

    std::cout << "指向常量的常指针" << std::endl << std::endl;
}
```


### 总结

`C++` 的语言规范: `const` 修饰的是离它最近的类型
```c++
// 指向const对象的指针或者说指向常量的指针。
// 修饰 char , * a 不可修改
const char * a; 
// 同上
char const * a; 
// 指向类型对象的const指针。或者说常指针、const指针。
// 修饰的是 char *, 指针指向的内存地址不可修改
char * const a; 
// 指向const对象的const指针。
const char * const a; 
```

`const` 右边没有指针*的话,是不参与类型的
```
int*         <= const int*   // 错误
const int*   <= int *        // 正确

int**        <= const int**  // 错误
const int**  <= int**        // 错误

int*   <= const int * // 错误
int*   <= const int * // 错误
int*   <= const int * // 错误
```

### 参考
[【C/C++】 常量指针，指针常量、指向常量的常指针详解](https://blog.csdn.net/as480133937/article/details/120804503)
[C++ 那些事 · const 那些事](https://light-city.github.io/stories_things/basic_content/const/#6const)
[【C++每日知识点】const int*、const int * const 和 int const * 之间的区别](https://zhuanlan.zhihu.com/p/655904545)

## const 与函数